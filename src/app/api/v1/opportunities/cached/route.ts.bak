import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { cacheManager } from '@/lib/cache';
import { cacheConfig } from '@/lib/cache/config';

export async function GET(request: NextRequest) {
  try {
    const { userId } = auth();
    
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const filters = {
      status: searchParams.get('status'),
      agency: searchParams.get('agency'),
      keyword: searchParams.get('keyword'),
      minAmount: searchParams.get('minAmount'),
      maxAmount: searchParams.get('maxAmount'),
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '10'),
    };

    // Generate cache key based on filters
    const cacheKey = cacheManager.listCacheKeyFor('opportunities', filters);

    // Use cache wrapper to get opportunities
    const result = await cacheManager.withCache(
      cacheKey,
      async () => {
        // Simulate API call to fetch opportunities
        // In real implementation, this would call your opportunity service
        return await fetchOpportunitiesFromAPI(filters);
      },
      {
        ttl: cacheConfig.ttl.medium, // 30 minutes
        userId,
        prefix: cacheConfig.prefixes.opportunity,
      }
    );

    return NextResponse.json({
      opportunities: result.data,
      cached: result.cached,
      cacheKey: result.key,
      pagination: {
        page: filters.page,
        limit: filters.limit,
        total: result.data.length,
      },
    });
  } catch (error) {
    console.error('Cached opportunities API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

async function fetchOpportunitiesFromAPI(filters: any) {
  // Mock implementation - replace with actual API calls
  const mockOpportunities = [
    {
      id: '1',
      title: 'IT Services Contract',
      agency: 'Department of Defense',
      amount: 500000,
      status: 'active',
      deadline: '2024-12-31',
      description: 'Software development and maintenance services',
      naicsCode: '541511',
      setAside: 'Small Business',
      createdAt: new Date().toISOString(),
    },
    {
      id: '2',
      title: 'Consulting Services',
      agency: 'Department of Health',
      amount: 250000,
      status: 'active',
      deadline: '2024-11-30',
      description: 'Strategic consulting for healthcare systems',
      naicsCode: '541611',
      setAside: 'Unrestricted',
      createdAt: new Date().toISOString(),
    },
  ];

  // Apply filters
  let filteredOpportunities = mockOpportunities;

  if (filters.status) {
    filteredOpportunities = filteredOpportunities.filter(
      opp => opp.status === filters.status
    );
  }

  if (filters.agency) {
    filteredOpportunities = filteredOpportunities.filter(
      opp => opp.agency.toLowerCase().includes(filters.agency.toLowerCase())
    );
  }

  if (filters.keyword) {
    filteredOpportunities = filteredOpportunities.filter(
      opp => 
        opp.title.toLowerCase().includes(filters.keyword.toLowerCase()) ||
        opp.description.toLowerCase().includes(filters.keyword.toLowerCase())
    );
  }

  if (filters.minAmount) {
    filteredOpportunities = filteredOpportunities.filter(
      opp => opp.amount >= parseInt(filters.minAmount)
    );
  }

  if (filters.maxAmount) {
    filteredOpportunities = filteredOpportunities.filter(
      opp => opp.amount <= parseInt(filters.maxAmount)
    );
  }

  // Apply pagination
  const startIndex = (filters.page - 1) * filters.limit;
  const endIndex = startIndex + filters.limit;
  
  return filteredOpportunities.slice(startIndex, endIndex);
}